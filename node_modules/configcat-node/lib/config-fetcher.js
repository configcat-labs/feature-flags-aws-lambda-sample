"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpConfigFetcher = void 0;
var configcat_common_1 = require("configcat-common");
var http = require("http");
var https = require("https");
var tunnel = require("tunnel");
var url_1 = require("url");
var HttpConfigFetcher = /** @class */ (function () {
    function HttpConfigFetcher() {
    }
    HttpConfigFetcher.prototype.handleResponse = function (response, resolve, reject) {
        try {
            var _a = response, statusCode_1 = _a.statusCode, reasonPhrase_1 = _a.statusMessage;
            if (statusCode_1 === 200) {
                var eTag_1 = response.headers["etag"];
                var chunks_1 = [];
                response
                    .on("data", function (chunk) { return chunks_1.push(chunk); })
                    .on("end", function () {
                    try {
                        resolve({ statusCode: statusCode_1, reasonPhrase: reasonPhrase_1, eTag: eTag_1, body: Buffer.concat(chunks_1).toString() });
                    }
                    catch (err) {
                        reject(err);
                    }
                })
                    .on("error", function (err) { return reject(new configcat_common_1.FetchError("failure", err)); });
            }
            else {
                // Consume response data to free up memory
                response.resume();
                resolve({ statusCode: statusCode_1, reasonPhrase: reasonPhrase_1 });
            }
        }
        catch (err) {
            reject(err);
        }
    };
    HttpConfigFetcher.prototype.fetchLogic = function (options, lastEtag) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                options.logger.debug("HttpConfigFetcher.fetchLogic() called.");
                var baseUrl = options.getUrl();
                var isBaseUrlSecure = baseUrl.startsWith("https");
                var agent = void 0;
                if (options.proxy) {
                    try {
                        var proxy = new url_1.URL(options.proxy);
                        var agentFactory = void 0;
                        if (proxy.protocol === "https:") {
                            agentFactory = isBaseUrlSecure ? tunnel.httpsOverHttps : tunnel.httpOverHttps;
                        }
                        else {
                            agentFactory = isBaseUrlSecure ? tunnel.httpsOverHttp : tunnel.httpOverHttp;
                        }
                        agent = agentFactory({
                            proxy: {
                                host: proxy.hostname,
                                port: proxy.port,
                                proxyAuth: (proxy.username && proxy.password) ? "".concat(proxy.username, ":").concat(proxy.password) : null
                            }
                        });
                    }
                    catch (_a) {
                        options.logger.error("Failed to parse options.proxy: ".concat(options.proxy));
                    }
                }
                var requestOptions = {
                    agent: agent,
                    headers: {
                        "User-Agent": options.clientVersion,
                        "If-None-Match": lastEtag !== null && lastEtag !== void 0 ? lastEtag : null
                    },
                    timeout: options.requestTimeoutMs,
                };
                options.logger.debug(JSON.stringify(requestOptions));
                var request_1 = (isBaseUrlSecure ? https : http).get(baseUrl, requestOptions, function (response) { return _this.handleResponse(response, resolve, reject); })
                    .on("timeout", function () {
                    try {
                        request_1.destroy();
                    }
                    finally {
                        reject(new configcat_common_1.FetchError("timeout", options.requestTimeoutMs));
                    }
                })
                    .on("error", function (err) { return reject(new configcat_common_1.FetchError("failure", err)); })
                    .end();
            }
            catch (err) {
                reject(err);
            }
        });
    };
    return HttpConfigFetcher;
}());
exports.HttpConfigFetcher = HttpConfigFetcher;

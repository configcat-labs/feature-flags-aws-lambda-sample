import { IEventEmitter, IEventProvider } from "./EventEmitter";
import { ProjectConfig } from "./ProjectConfig";
import type { IEvaluationDetails } from "./RolloutEvaluator";
export type HookEvents = {
    clientReady: [];
    flagEvaluated: [evaluationDetails: IEvaluationDetails];
    configChanged: [newConfig: ProjectConfig];
    clientError: [message: string, exception?: any];
};
/** Defines hooks (events) for providing notifications of `ConfigCatClient`'s actions. */
export interface IProvidesHooks extends IEventProvider<HookEvents> {
}
export declare class Hooks implements IProvidesHooks, IEventEmitter<HookEvents> {
    private eventEmitter;
    constructor(eventEmitter: IEventEmitter);
    tryDisconnect(): boolean;
    /** @inheritdoc */
    addListener: <TEventName extends keyof HookEvents>(eventName: TEventName, listener: (...args: HookEvents[TEventName]) => void) => this;
    /** @inheritdoc */
    on<TEventName extends keyof HookEvents>(eventName: TEventName, listener: (...args: HookEvents[TEventName]) => void): this;
    /** @inheritdoc */
    once<TEventName extends keyof HookEvents>(eventName: TEventName, listener: (...args: HookEvents[TEventName]) => void): this;
    /** @inheritdoc */
    removeListener<TEventName extends keyof HookEvents>(eventName: TEventName, listener: (...args: HookEvents[TEventName]) => void): this;
    /** @inheritdoc */
    off: <TEventName extends keyof HookEvents>(eventName: TEventName, listener: (...args: HookEvents[TEventName]) => void) => this;
    /** @inheritdoc */
    removeAllListeners(eventName?: keyof HookEvents): this;
    /** @inheritdoc */
    listeners(eventName: keyof HookEvents): Function[];
    /** @inheritdoc */
    listenerCount(eventName: keyof HookEvents): number;
    /** @inheritdoc */
    eventNames(): Array<keyof HookEvents>;
    /** @inheritdoc */
    emit<TEventName extends keyof HookEvents>(eventName: TEventName, ...args: HookEvents[TEventName]): boolean;
}
//# sourceMappingURL=Hooks.d.ts.map